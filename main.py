import random  # Imports random module which contains functions to generate random numbers - used in randomizing
# events throughout my code
import os  # Imports os module which contains functions to generate random sequences - helps in true randomization

random.seed(os.urandom(1024))  # Initializes the random number generator (RNG) with a seed value. A seed ensures the
# reproducibility of random-generated sequences. Here, it's being seeded with a random byte sequence generated by
# os.urandom(1024), making the RNG's starting state highly unpredictable and varying across different executions.


def setup_player():  # Initializes the player dictionary
    player = {  # dictionary that holds player information
        'name': introduction(),  # Name of the player, set in introduction
        'hp': 0,  # Set by player_class function, players health
        'level': 1,  # All characters start at one, players level
        'location': None,  # Will be set to current location of player
        'class': None,  # This will be set by the player_class function
        'Attacks knight': [{'Name': 'Slash', 'MinDamage': 12, 'MaxDamage': 14},  # Attacks for player based on chosen
                           # player class
                           {'Name': 'Great swing', 'Damage':13}],
        'Attacks samurai': [{'Name': 'bleed', 'MinDamage': 7, 'MaxDamage': 16},
                            {'Name': 'split', 'Damage': 12}],
        'Attacks mage': [{'Name': 'rock throw', 'MinDamage': 11, 'MaxDamage': 14},
                         {'Name': 'azure pebble', 'Damage': 12}],
        'Attacks bandit': [{'Name': 'Stab', 'MinDamage': 8, 'MaxDamage': 15},
                           {'Name': 'cut', 'Damage': 13}],
    }

    return player_class(player)  # Returns player information to the player_class function


def wait_for_input():  # Function that serves as both a restart function and an input dependent dialogue divide
    print('')  # Prints a blank line for user readability
    controls_read = input("0 to restart game, any other key to continue: ")
    while controls_read == "":  # Loop that runs until player inputs a valid command
        print('')
        break  # Breaks from loop
    if controls_read == '0':
        reset_player()  # Restarts game
    return controls_read  # Returns player to point at which function was called


enemies = [  # List that holds a dictionary for each encounter-able enemy type
    {'Name': 'Corrupted Guardian', 'HP': 35, 'Attack Name': 'Glitch Pulse', 'MinDamage': 5, 'MaxDamage': 8},
    {'Name': 'Code Fragment', 'HP': 45, 'Attack Name': 'Binary Barrage', 'MinDamage': 8, 'MaxDamage': 10},
    {'Name': 'Unsolvable Bug', 'HP': 60, 'Attack Name': 'Infinite Loop Lash', 'MinDamage': 10, 'MaxDamage': 12},
]

boss_enemies = [  # List that holds a dictionary for each encounter-able boss enemy type
    # random.randint picks a random value within a selected range
    {'Name': 'Architect of Desolation', 'HP': 60, 'Attack_Name': 'Eclipse of Ruin', 'MinDamage': 10, 'MaxDamage': 13},
    {'Name': 'The Eternal Compiler', 'HP': 65, 'Attack_Name': 'Syntax Surge', 'MinDamage': 13, 'MaxDamage': 16},
    {'Name': 'Pyroforge Incendrath', 'HP': 70, 'Attack_Name': 'Blazed Bind', 'MinDamage': 16, 'MaxDamage': 20},
]

items = [  # List that holds a dictionary which holds a list which holds a dictionary for each usable item
    {
        'Healing Items': [
            {'Type': 'Healing Item', 'Name': 'Potent Health Potion', 'Potency': 25, 'Amount': 0}
        ]
    }
]


#  A function is a contained set of a code that can can be called to perform a task throughout code
def introduction():  # Sets player name and introduces player into world
    print('')  # Prints empty line for better formatting in the console
    # Prompts the user to enter the name of their player and store it in the 'name' variable
    while True:  # A Code block which repeatedly executes until broken
        name = input("Enter the name of your hero: ")
        if name == '':
            print("The player must have a name")
        else:
            break
    print("")
    print(f'Welcome {name}, to Dark Pythons: Echoes of the Fallen Code.')
    print('Controls: W,A,S,D to move directions, type in your preferred action when provided.')
    print("After every line of dialogue, the game will wait for 0 to restart the game or any other input to continue ")
    wait_for_input()
    print("Remember, this is a story game, so make sure you do everything you can for the full experience!")
    wait_for_input()
    print("In a world where reality is intertwined with the digital, an ancient curse has fallen over the land of "
          "Pythorean; corrupting its code and trapping its \ninhabitants in an endless loop of death and despair. "
          "Legends tell of an emboldened hero who will traverse the treacherous depths of the Cursed Library, "
          "the winding \npaths of the Archives of Legacy Code, and the dreaded Enchanted Forge of Debugging, "
          "to find and reset the Core of Creation, thus lifting the curse and \nrestoring balance to Pythoria:")
    wait_for_input()

    print('================================================================')

    return name  # returns player name value for use in other functions


def print_player_info(player):  # Prints the players information stored in the player dictionary when called
    print(f"\nPlayer Information:")
    print(f"Name: {player['name']}")
    print(f"HP: {player['hp']}")
    print(f"Level: {player['level']}")
    #  Prints attacks based on player class choice
    if player['class'] == "knight":
        # Prints first and second index in the player 'Attacks knight' key
        attack_one = player['Attacks knight'][0]
        attack_two = player['Attacks knight'][1]
        print(f"Attack one: {attack_one['Name']} (Damage: {attack_one['MinDamage']} - {attack_one['MaxDamage']})")
        print(f"Attack two: {attack_two['Name']} (Damage: {attack_two['Damage']})")
    elif player['class'] == "samurai":
        attack_one = player['Attacks samurai'][0]
        attack_two = player['Attacks samurai'][1]
        print(f"Attack one: {attack_one['Name']} (Damage: {attack_one['MinDamage']} - {attack_one['MaxDamage']})")
        print(f"Attack two: {attack_two['Name']} (Damage: {attack_two['Damage']})")
    elif player['class'] == "mage":
        attack_one = player['Attacks mage'][0]
        attack_two = player['Attacks mage'][1]
        print(f"Attack one: {attack_one['Name']} (Damage: {attack_one['MinDamage']} - {attack_one['MaxDamage']})")
        print(f"Attack two: {attack_two['Name']} (Damage: {attack_two['Damage']})")
    elif player['class'] == "bandit":
        attack_one = player['Attacks bandit'][0]
        attack_two = player['Attacks bandit'][1]
        print(f"Attack one: {attack_one['Name']} (Damage: {attack_one['MinDamage']} - {attack_one['MaxDamage']})")
        print(f"Attack two: {attack_two['Name']} (Damage: {attack_two['Damage']})")

    wait_for_input()
    locked_room(player)


def player_class(player):  # Allows the player to pick a class
    class_choices = {  # Dictionary that holds all available class attributes
        'knight': {'hp': 100, 'attacks': player['Attacks knight']},  # Gets attacks from player dictionary
        'samurai': {'hp': 100, 'attacks': player['Attacks samurai']},
        'mage': {'hp': 100, 'attacks': player['Attacks mage']},
        'bandit': {'hp': 100, 'attacks': player['Attacks bandit']},
    }
    print("Welcome, fragmented one. You have been chosen by the order in hopes you have what it takes to find and "
          "reset the core of creation!")
    wait_for_input()
    print("The first step in your journey is picking your players class, Do you wish to be a fierce knight, "
          "a humble samurai, a keen mage, or a sneaky bandit")
    while True:
        class_choice = input("(knight/samurai/mage/bandit): ").lower()  # Makes console accept only lower case inputs
        if class_choice in class_choices:  # Checks if class_choice input is in class_choices
            player.update({  # Updates key's value according to class_choice
                'class': class_choice,
                'hp': class_choices[class_choice]['hp'],
                'attacks': class_choices[class_choice]['attacks'],
            })
            print_player_info(player)  # Prints player info
            break
        else:
            print("\nUnknown class. Your survival depends on making the right choices.")


def locked_room(player):  # Introductory level
    print('You wake up in a dimly lit room. The air is thick with dust and the scent of ancient parchment. You '
          'remember nothing of how you came to be here, only that \n the darkness outside this room calls to you, '
          'whispering of a curse and a core...:')
    while True:
        action = input("\nWhat do you do? (inspect/call/sit): ").lower().strip()
        if action == 'inspect':
            print("\nYour hands brush against the cold stone wall, feeling for a seam. Your fingers catch on a loose "
                  "stone and press it instinctively. A section of the wall grinds \nopen, revealing a sliver of "
                  "freedom.")
            wait_for_input()
            break
        elif action == 'call':
            print("\nYour voice echoes through unseen halls, met only by silence. It seems you are alone in this "
                  "predicament.")

        elif action == 'sit':
            print("\nAs despair threatens to take hold, you remind yourself that succumbing to it will not change "
                  "your fate. It's time to act.")
        else:
            print("\nUnknown action. Your survival depends on making the right choices.")

    print("\nStepping through the secret passage, you find yourself on a path winding through an ethereal landscape, "
          "torn between realms.")
    wait_for_input()
    print("Suddenly, the ground beneath you gives way, and you are consumed by swirling darkness...")
    wait_for_input()
    Cursed_Library(player)  # Takes player to second level


def choose_attack(player):  # Lets player choose between two attacks in player dictionary attacks key
    print("Choose your attack:")  # Prompts player to choose attack
    for i, attack in enumerate(player['attacks']):
        # Loops through the attacks available to the player. 'enumerate' is used to keep track of the index 'i' and
        # the 'attack' itself.
        if i == 0:
            print(f"{i + 1}. {attack['Name']} (Damage: {attack['MinDamage']}-{attack['MaxDamage']})")
            # If it's the first attack (index 0), format and print its details differently.
        elif i == 1:
            print(f"{i + 1}. {attack['Name']} (Damage: {attack['Damage']})")
            # If it's the second attack (index 1), format and print its details. This is tailored to how its damage
            # is stored.
    while True:
        try:
            choice = int(input()) - 1  # Captures the user's choice via input. Subtracts 1 to convert from 1-based to
            # 0-base indexing.

            # If the choice is not within the valid range, raise a ValueError.
            if choice < 0 or choice >= len(player['attacks']):
                raise ValueError

            break

        except ValueError:
            # If a ValueError is caught, inform the user and prompt them to try again.
            print("Invalid choice. Please enter a valid attack number: ")

    return choice  # Returns the user's choice as an index of the selected attack


def game_reload(player):  # Function that resets players location upon death
    if player['hp'] <= 0:
        print("You died! Resetting game at the beginning of current level ")
        player['hp'] = 100
        items[0]['Healing Items'][0]['Amount'] = 0
        if player['location'] == 'Enchanted Forge of Debugging':
            Enchanted_Forge_of_Debugging(player)
        elif player['location'] == 'Cursed Library':
            Cursed_Library(player)
        elif player['location'] == 'Archives of Legacy Code':
            Archives_of_Legacy_Code(player)
        else:
            print(f"Location {player['location']} not found. Unable to restart level.")


def attack_system(player):  # Function that allows player to pick between attacking and accessing their inventory
    while True:  # Keep asking until a valid input is received
        player_action = input("Do you want to attack or use an item? (A/I): ").upper()
        if player_action == 'A':
            chosen_attack_index = choose_attack(player)
            chosen_attack = player['attacks'][chosen_attack_index]
            # Checks if chosen attack has both Min and MaxDamage keys in chosen_attack index
            if 'MinDamage' in chosen_attack and 'MaxDamage' in chosen_attack:
                damage = random.randint(chosen_attack['MinDamage'], chosen_attack['MaxDamage'])
            # Checks if chosen attack index has a fixed 'Damage' value
            elif 'Damage' in chosen_attack:
                damage = chosen_attack['Damage']
            else:
                # Handles an unexpected case
                print("Invalid attack configuration. Please check the attack settings.")
                continue  # Ask for action again

            return {
                'action': 'attack',
                'damage': damage,
                'attack_name': chosen_attack['Name']
            }

        elif player_action == 'I' and items[0]['Healing Items'][0]['Amount'] > 0:
            return {'action': 'item'}

        elif player_action == 'I' and items[0]['Healing Items'][0]['Amount'] == 0:
            print("You have no items to use.")
            wait_for_input()
            continue

        else:
            print("Invalid input. Please enter 'A' for attack or 'I' for item.")


def player_levelling(player):  # This function increases the damage attributes of the players attacks
    print('An IDE appears before you. It holds the message "Congratulations player, you have gained a level, '
          'your abilities will be increased correspondingly"')
    wait_for_input()

    increase_min = 2  # defines how much the min damage will increase
    increase_max = 3  # defines how much the max damage will increase
    increase_damage = 3  # defines how much the damage will increase

    # Define the keys for different attack classes
    attack_keys = ['Attacks knight', 'Attacks samurai', 'Attacks mage', 'Attacks bandit']

    # Loop over each attack class key
    for key in attack_keys:
        if key in player:  # Check if the key exists in player dictionary
            # Iterate over each attack in the specified class
            for attack in player[key]:
                # Check and update 'MinDamage' and 'MaxDamage' if they exist
                if 'MinDamage' in attack and 'MaxDamage' in attack:
                    attack['MinDamage'] += increase_min
                    attack['MaxDamage'] += increase_max
                # Check and update 'Damage' if it exists
                elif 'Damage' in attack:
                    attack['Damage'] += increase_damage

    return player


def battle(player):
    # This function controls the battle mechanics between the player and an enemy based on the player's current location
    # The 'player' parameter is a dictionary containing details about the player, including their location
    # Initializes enemy to none
    enemy = None

    # Depending on the player's location, select an appropriate enemy from a predefined list 'enemies'
    if player['location'] == 'Cursed Library':
        enemy = enemies[0]
        enemy['HP'] = 35  # Resets enemy HP
    elif player['location'] == 'Archives of Legacy Code':
        enemy = enemies[1]
        enemy['HP'] = 50
    elif player['location'] == 'Enchanted Forge of Debugging':
        enemy = enemies[2]
        enemy['HP'] = 75

    # Enter a loop to simulate the turn-based combat.
    while player['hp'] and enemy['HP'] > 0:
        #  Initializes variable to false which checks if player has taken their turn
        player_turn = False
        # Depending on the player's location, select an appropriate enemy from a predefined list 'enemies'

        # Calls the attack_system function with the player as argument to perform an action
        action_result = attack_system(player)
        if action_result['action'] == 'attack':
            player_turn = True
            print(f"You use {action_result['attack_name']} dealing {action_result['damage']} damage.")  # Displays
            # the attack and damage details
            enemy['HP'] -= action_result['damage']  # Subtracts the damage taken from action_result from enemy hp
            # Checks if the enemy has been defeated.
            if enemy['HP'] <= 0:
                print(f"You have defeated the {enemy['Name']}!")
                return

        if enemy['HP'] <= 0:
            print(enemy['HP'])
            print(f"You have defeated the {enemy['Name']}!")
            return

        # If the action result is "item", it indicates the player chose to use an item.
        elif action_result['action'] == "item":
            player_turn = False
            player_inventory(player, items)

        # If the action result is not a tuple or "item", it's considered an invalid action
        else:
            print("Invalid action. Please choose again.")

        # Enemy's turn to attack
        if enemy['HP'] > 0 and player_turn:
            enemy_damage = random.randint(enemy['MinDamage'], enemy['MaxDamage'])  # Random damage calculation
            print(f"The {enemy['Name']} attacks you for {enemy_damage} damage.")
            player['hp'] -= enemy_damage
            # After each round, display the current health of both the player and the enemy.
            print(f"Your HP: {player['hp']}, Enemy HP: {enemy['HP']}")
    # Check if the player has been defeated
    if player['hp'] > 0:
        print(f"With {enemy['Name']} defeated, the path forward is clear.")
        return True
    else:
        print(f"As darkness closes in, the last thing you hear is {enemy['Name']}'s triumphant roar.")
        game_reload(player)


def cursed_library_puzzle(player):  # Puzzle which needs to be solving to let player continue cursed library level
    attempts = 0
    print("\nThe Ethereal Librarian presents you with a final challenge: 'To find the Archives of Legacy Code, "
          "you must first link this riddle to its corresponding tome: I speak \nwithout a mouth and hear without "
          "ears. I have no body, but I come alive with wind. What am I?'")
    print("\n1. The Whispering Tome")
    print("2. The Eternal Chasm")
    print("3. The Silent Watcher")
    print("4. The Boundless Echo")

    while attempts <= 2:
        answer = input("Choose the correct book (Enter 1, 2, 3, or 4): ")
        if answer == "4":
            print("\nCorrect! The Boundless Echo holds the key to breaking the curse. As you speak the title, the book "
                  "glows with a soft light, guiding you to the Archives of \nLegacy Code.")
            return
        else:
            attempts += 1
            print("\nIncorrect. The library's curse grows stronger, repelling you with a forceful energy. You must "
                  "prepare to try again.")

    if attempts > 2:
        print("You have tried to many times, you are not fit for this journey.")
        game_reload(player)


def archives_of_legacy_code_puzzle(player):  # Puzzle which needs to be solved within the archives of legacy code level
    # to let player continue
    attempts = 0
    print("\nTo access the deepest secrets of the Archives, you must reconstruct the Ancient Code. Arrange the "
          "following code snippets in the correct order.")

    correct_order = 'DBCA'
    print("\nA. Code.execute()")
    print("B. Code.compile()")
    print("C. Code.debug()")
    print("D. Code.write()")

    while attempts <= 2:
        order = input("Enter the letters in the correct order (e.g., ABCD): ").upper()
        if order == correct_order:  # Checks if inputted order is the same as the pre-defined correct order string
            print("\nYou've successfully reconstructed the Ancient Code. The archive's secrets unveil themselves, "
                  "guiding you towards the truth of Pythoria's corruption.")
            return
        else:
            attempts += 1
            print("\nThe code fragments reject your arrangement. You must clear your "
                  "mind and attempt the puzzle once more.")
    if attempts > 2:
        print("You have tried to many times, you are not fit for this journey.")
        game_reload(player)


def boss_enemy_info(player):
    # This function provides information about a boss enemy based on the player's current location.
    # It's designed to be called when initiating a boss fight.

    # Check if the player's location is the 'Cursed Library'.
    if player['location'] == 'Cursed Library':
        # Selects the corresponding boss enemy from a predefined list of boss enemies.
        boss_enemy = boss_enemies[0]
        # Sets the round number for the boss battle.
        rounds = 1
        # Extracts relevant information about the boss enemy for use in the battle.
        boss_name = boss_enemy['Name']
        boss_initial_hp = boss_enemy['HP']
        boss_attack_name = boss_enemy['Attack_Name']
        print(f"The battle against {boss_enemy['Name']} begins!")
        # Returns all relevant information
        return rounds, boss_name, boss_initial_hp, boss_enemy, boss_attack_name

    elif player['location'] == "Enchanted Forge of Debugging":
        boss_enemy = boss_enemies[2]
        rounds = 2
        boss_name = boss_enemy['Name']
        boss_initial_hp = boss_enemy['HP']
        boss_attack_name = boss_enemy['Attack_Name']
        print(f"The battle against {boss_enemy['Name']} begins!")
        return rounds, boss_name, boss_initial_hp, boss_enemy, boss_attack_name

    elif player['location'] == "Archives of Legacy Code":
        boss_enemy = boss_enemies[1]
        rounds = 3
        boss_name = boss_enemy['Name']
        boss_initial_hp = boss_enemy['HP']
        boss_attack_name = boss_enemy['Attack_Name']
        print(f"The battle against {boss_enemy['Name']} begins!")
        return rounds, boss_name, boss_initial_hp, boss_enemy, boss_attack_name


def boss_enemy_battle(player):  # Simulates a battle against a boss enemy
    # Retrieve boss enemy information based on the player's location
    rounds, boss_name, boss_initial_hp, boss_enemy, boss_attack_name = boss_enemy_info(player)

    print(f"\n--- Round 1: The battle against {boss_name} begins! ---")
    current_round = 1  # sets current round
    player_turn = False

    # Continues the battle while both the player and the boss have health above 0.
    while player['hp'] > 0 and boss_enemy['HP'] > 0:
        # Player's turn: Call a function to perform an attack and receive the result.
        action_result = attack_system(player)
        if action_result['action'] == 'attack':
            player_turn = True
            print(f"You use {action_result['attack_name']} dealing {action_result['damage']} damage.")  # Displays
            # the attack and damage details
            boss_enemy['HP'] -= action_result['damage']  # Subtracts the damage taken from action_result from enemy hp
            # Checks if the enemy has been defeated.
            if boss_enemy['HP'] <= 0:
                print(f"You have defeated {boss_name}!")
                break  # Exit the battle loop if the boss is defeated.
        elif action_result['action'] == "item":
            player_turn = False
            player_inventory(player, items)
            continue  # Immediately continue to next iteration without boss attack.
        else:  # If the action result is not a valid attack (not a tuple), prompt for another action.
            print("Invalid action. Please choose again.")
            continue  # Skips the rest of the loop and start at the beginning.

        # Boss's turn
        if boss_enemy['HP'] > 0 and player_turn:
            boss_damage = random.randint(boss_enemy['MinDamage'], boss_enemy['MaxDamage'])  # Random damage calculation
            print(f"{boss_name} attacks you with {boss_attack_name} dealing {boss_damage} damage.")
            player['hp'] -= boss_damage
            if player['hp'] <= 0:
                print("You were defeated!")
                game_reload(player)
                return False

        # Display current health statuses
        print(f"Your HP: {player['hp']}, {boss_name}'s HP: {boss_enemy['HP']}")

        # Boss healing mechanic, triggered if boss's HP falls below half and hasn't healed yet.
        if boss_enemy['HP'] < boss_initial_hp / 2 and 'healed' not in boss_enemy:
            heal_amount = random.randint(20, 40)  # Randomly determine healing amount between a range of 20-40
            boss_enemy['HP'] += heal_amount  # Apply healing to boss's HP.
            boss_enemy['healed'] = True  # Mark the boss as having used heal.
            print(f"{boss_name} uses their power to heal, restoring {heal_amount} HP!")

        current_round += 1  # Move to the next round.
        # Announce the status of the battle based on the current round number.
        if current_round > rounds:
            print("")
        else:
            print(f"\n--- Round {current_round}: The battle continues! ---")

    if player['hp'] > 0:
        print(f"With {boss_name} defeated, the path forward is clear.")
        return True
    else:
        print(f"As darkness closes in, the last thing you hear is {boss_name}'s triumphant roar.")
        game_reload(player)


def player_inventory(player, items):  # This function calls the amount key of the items list then uses the potency key
    # of that item to heal the player
    while True:
        user_choice = input("Use a potion to regain health? (yes/no)").lower()
        if user_choice == "yes":
            if items[0]['Healing Items'][0]['Amount'] > 0:  # Check if there is at least one potion available
                player['hp'] += items[0]['Healing Items'][0]['Potency']
                items[0]['Healing Items'][0]['Amount'] -= 1  # Decrement potion count after use
                print(f"Potion used. You gained 25 hp. Remaining potions: {items[0]['Healing Items'][0]['Amount']}.")
                break  # Exit the loop after using a potion
            else:
                print("You don't have any potions left in your inventory.")
                return  # Return after notifying the player about potion unavailability
        elif user_choice == "no":
            print("You decided against using a potion.")
            break  # Exit the loop if the player decides not to use a potion
        else:
            print("Invalid input, please enter 'yes' or 'no'.")  # Prompt again if input is invalid


def Cursed_Library(player):  # Second playable area of the game
    player['location'] = "Cursed Library"  # Sets player location to current level
    print("Confused and distraught, you stumble to your feet.")
    wait_for_input()
    print('Met with an error filled IDE, a message presents itself, "Welcome to the Cursed Library"')
    wait_for_input()
    print("\nWalking past the IDE, you find yourself before two archaic, towering doors. You step through, "
          "and the scent of ancient knowledge and forgotten tales fills \nyour nostrils. Shelves upon shelves of "
          "glowing tomes line the endless halls, each tome another player, lost within the librarys halls, "
          "for all eternity.")
    wait_for_input()

    print("\nYou're approached by an ethereal librarian, a ghostly figure bound to serve the library for eternity. "
          "'Welcome, traveler,' the librarian rasps. 'Beware \nthe corrupted knowledge and the guardians that protect "
          "it. Seek out the Archives of Legacy Code to break the curse. But first, prove your worth.'")
    wait_for_input()

    print("\nTwo corrupted guardians approach, their forms flickering between reality and code. It's time to battle.")
    battle(player)  # Takes player to battle function

    # Checks if the player was defeated in the battle; if so, restarts the level.

    print("With the first enemy defeated, the second charges at you in a state of rage")
    wait_for_input()
    battle(player)

    print("\nWith the guardians defeated, the librarian nods in approval. 'You possess strength and resolve. The "
          "Archives of Legacy Code lies beyond the Great Hall, guarded \nby the Architect of Desolation. Prepare "
          "yourself.'")
    wait_for_input()

    # Introducing a New NPC: The Lost Coder
    print("\nVenturing deeper, you encounter a Lost Coder, trapped in the library's curse. 'I can offer you "
          "assistance,' the coder says, handing you a potent healing \ncode fragment.")
    items[0]['Healing Items'][0]['Amount'] += 2  # Adds a healing item to the player's inventory.
    print("'Use it wisely, for the Architect is no ordinary foe.'")
    print(" (+ 2 healing items to the player's inventory)")
    wait_for_input()

    # Approaching the Boss Battle
    print("\nThe Great Hall looms before you, vast and filled with the hum of corrupted data. At its center, "
          "the Architect of Desolation, a colossal entity of code and \nmalice, guards your entrance to the Archives.")
    wait_for_input()
    print("'Foolish traveler,' it booms. 'You dare challenge my dominion? Come then, and fall like those before you.'")
    boss_enemy_info(player)
    boss_enemy_battle(player)  # Takes player to boss battle function
    wait_for_input()
    player_levelling(player)  # Takes player to levelling function

    print("As the Architect of Desolation crumbles, you turn around, expecting to be granted passage, "
          "but the librarians aura implys otherwise.")
    wait_for_input()
    print('"The librarian mumbles, "you have one final challenge".')
    cursed_library_puzzle(player)  # Takes player to cursed library puzzle

    Archives_of_Legacy_Code(player)  # Directs player to next Archives_of_Legacy_Code function


def Archives_of_Legacy_Code(player):  # This function is the second playable area for the player
    player['location'] = "Archives of Legacy Code"
    print("\nLeaving the Cursed Library behind, you follow a trail of glitched reality, leading to the Archives of "
          "Legacy Code. This ancient repository houses the source codes of Pythoria, including scripts so old and "
          "powerful that few dare to examine them.")
    wait_for_input()

    print("\nAs you navigate through towering stacks of parchments and scrolls, the air crackles with static energy. "
          "Suddenly, an avatar of the Archive's guardian materializes before you. 'Welcome, seeker of truths,' it "
          "intones. 'Here lies the foundation of all that Pythoria was, is, and will be. But be warned, some "
          "truths might just rewrite you.'")
    wait_for_input()
    print("'I have prepared something of test of courage to celebrate your arrival. But first, demonstrate your wit.'")
    archives_of_legacy_code_puzzle(player)

    print("Deciphering the Ancient Code reveals a hidden history of Pythoria, written by the first codemancers who "
          "sought to blend magic and technology. You learn of the Original Bug, a flaw so severe that it "
          "threatened to unravel the fabric of reality.")
    wait_for_input()
    print("'To prepare you for the battles ahead, take these'")
    items[0]['Healing Items'][0]['Amount'] += 3
    print(" + 3 healing potions added to players inventory")
    wait_for_input()
    print("'Now, demonstrate your strength!'.")
    battle(player)

    print("A valiant display of strength. You are ready to face the Archives master")
    wait_for_input()
    # Boss Battle: Archivist of Corruption
    print("\nAs you continue with your journey, delving deeper and deeper into the Archives, you encounter the "
          "The eternal compiler, a twisted amalgamation"
          "of corrupted code and compiled knowledge. It guards the darkest secrets of Pythoria's past.")
    wait_for_input()
    print("The eternal compiler's eyes flare with dark power as it prepares to strike. It's time to battle!")
    boss_enemy_info(player)
    boss_enemy_battle(player)
    wait_for_input()
    player_levelling(player)

    print("\nThe Archivist of Corruption falls, its essence dispersing like digital smoke. With its defeat, the way "
          "forward clears, and you can continue your quest for truth.")
    wait_for_input()

    # Introducing the Concept of the Debugging Forge
    print("\nAmong the texts, you find a reference to the Enchanted Forge of Debugging, created by the ancients as a "
          "means to combat the Original Bug. It speaks of a powerful artifact, the Ultimate Debugging Tool, "
          "capable of purging the deepest corruptions.")
    wait_for_input()

    print("'To seek the forge is to seek the salvation of Pythoria,' the guardian's voice echoes in your mind as "
          "you prepare to leave the Archives. 'But be forewarned, the path is perilous and the forge's protector, "
          "Pyroforge Incendrath, allows no one to wield its power unchecked.'")
    wait_for_input()

    print("\nWith newfound knowledge and determination, you step out of the Archives of Legacy Code. Ahead lies the "
          "journey to the Enchanted Forge of Debugging, where the fate of Pythoria awaits to be rewritten.")
    wait_for_input()

    # Resetting the player's location or directing them to the next part of the adventure
    Enchanted_Forge_of_Debugging(player)


def Enchanted_Forge_of_Debugging(player):  # This function serves as the third area of the game and features the
    # final boss battle
    player['location'] = "Enchanted Forge of Debugging"
    print("\nPushing open the heavy, steel doors of the Enchanted Forge of Debugging, you're greeted by the heat of "
          "flames and the clang of hammer on anvil. This forge crafts not just weapons, but also spells and codes "
          "to debug reality itself. Each artifact here holds the power to alter the fabric of Pythoria.")
    wait_for_input()

    print("\nA figure emerges from the shadows, their eyes glowing with a coder's fire. 'Ah, a brave soul has "
          "arrived,' they announce, their voice echoing through the vast chamber. 'I am the Forge Master, keeper "
          "of this place. If you seek to wield the power of debugging, you must first demonstrate your capability "
          "by repairing the Corrupted Golem.'")
    wait_for_input()
    print("To aid you in your task, I shall bestow upon you my collection of potions")
    print(" + 4 healing potions added to player inventory")
    items[0]['Healing Items'][0]['Amount'] += 4
    wait_for_input()

    print("\nWith a wave of the Forge Master's hand, the Corrupted Golem lumbers toward you, its code visibly glitching"
          "with malice. This is your first challenge.")
    battle(player)

    print("The Golem crumbles to the ground, its corrupted code purged. The Forge Master nods in approval, 'Well done. "
          "But greater challenges await.'")
    wait_for_input()

    # Introducing a New NPC: The Apprentice Debugger
    print("\nAs you delve deeper into the forge, you encounter an Apprentice Debugger, eager but overwhelmed. 'I "
          "discovered a potent Debugging potion, but it's too much for me to handle,' they say, offering it to you.")
    items[0]['Healing Items'][0]['Amount'] += 1
    print("'Use this in your forthcoming battle. The Pyroforge Incendrath, guardian of the forge, will not fall "
          "easily.'")
    wait_for_input()

    print("\nWithin the roaring flames of the Enchanted Forge of Debugging, Pyroforge Incendrath emerges as the fiery "
          "guardian of the realm. Born from the molten depths of digital infernos, this entity embodies the "
          "relentless fury of the forge itself. Its attacks blaze with incendiary power, engulfing adversaries in "
          "waves of scorching heat and relentless combustion. Pyroforge Incendrath's presence serves as both a trial "
          "by fire and a testament to the forge's unrivaled potency, challenging brave souls who dare to tread its "
          "fiery halls.")
    boss_enemy_info(player)
    boss_enemy_battle(player)
    wait_for_input()

    print("\nAs Pyroforge Incendrathdissolves, its fragments scattering like lost data, the core of the forge reveals the "
          "Ultimate Debugging Tool. You grasp it, and a wave of clarity washes over the forge.")
    wait_for_input()

    print("\nCalmness envelops the forge as its corrupted elements are debugged and order is restored. The Forge "
          "Master approaches, offering a smile. 'You have done what many believed impossible. The Enchanted Forge "
          "of Debugging shall now create tools for the betterment of Pythoria.'")
    print("\nThe forge's doors open to the world outside, promising new adventures. Yet, the tale of Pythoria is "
          "far from over...")
    wait_for_input()

    end_card()


def end_card():
    print("\n======================= The End of Your Journey =======================")
    print("\nWith the Ultimate Debugging Tool in hand, you stand at the precipice of a new era for Pythoria.")
    wait_for_input()
    print("The corrupted data streams have been purified, and reality itself bends to the will of your newfound power.")
    wait_for_input()
    print("As the sun rises over the digital horizon, you realize that your journey has not just changed Pythoria,")
    wait_for_input()
    print("but you as well. What once was a quest for survival has become a tale of triumph and transformation.")
    wait_for_input()
    print("\nThank you for journeying through the lands of Pythoria, brave debugger. Your deeds will be remembered")
    wait_for_input()
    print("in the annals of code and beyond, a testament to the strength and courage that dwells within us all.")
    wait_for_input()
    print("\nWould you like to relive the adventure? (Yes/No)")

    choice = input("> ").lower()
    if choice == "yes":
        print("\nRekindling the flames of adventure, you step once more into the world of Pythoria...")
        reset_player()
    elif choice == "no":
        print("\nFarewell, brave adventurer. Until we meet again in tales yet untold.")
    else:
        print("\nI didn't understand that choice. The adventure awaits your return, whenever you're ready.")


def reset_player():  # resets all values needed for game restart
    player = {
        'name': introduction(),
        'hp': 0,
        'level': 1,
        'location': None,
        'class': None,
        'Attacks knight': [{'Name': 'Slash', 'MinDamage': 7, 'MaxDamage': 9},
                           {'Name': 'Great swing', 'Damage': 9}],
        'Attacks samurai': [{'Name': 'bleed', 'MinDamage': 4, 'MaxDamage': 12},
                            {'Name': 'split', 'Damage': 7}],
        'Attacks mage': [{'Name': 'rock throw', 'MinDamage': 8, 'MaxDamage': 10},
                         {'Name': 'azure pebble', 'Damage': 9}],
        'Attacks bandit': [{'Name': 'Stab', 'MinDamage': 5, 'MaxDamage': 11},
                           {'Name': 'cut', 'Damage': 9}],
    }

    enemies = [  # List that holds a dictionary for each encounter-able enemy type
        {'Name': 'Corrupted Guardian', 'HP': 35, 'Attack Name': 'Glitch Pulse', 'Damage': 5},
        {'Name': 'Code Fragment', 'HP': 50, 'Attack Name': 'Binary Barrage', 'Damage': 8},
        {'Name': 'Unsolvable Bug', 'HP': 50, 'Attack Name': 'Infinite Loop Lash', 'Damage': 10, },
    ]

    boss_enemies = [  # List that holds a dictionary for each encounter-able boss enemy type
        {'Name': 'Architect of Desolation', 'HP': 100, 'Attack_Name': 'Eclipse of Ruin',
         'Damage': random.randint(10, 15)},  # random.randint picks a random value within a selected range
        {'Name': 'The Eternal Compiler', 'HP': 150, 'Attack_Name': 'Syntax Surge', 'Damage': random.randint(15, 20)},
        {'Name': 'Pyroforge Incendrath', 'HP': 200, 'Attack_Name': 'Blazed Bind', 'Damage': random.randint(20, 25)},
    ]

    items = [  # List that holds a dictionary which holds a list which holds a dictionary for each usable item
        {
            'Healing Items': [
                {'Type': 'Healing Item', 'Name': 'Potent Health Potion', 'Potency': 25}
            ]
        }
    ]

    main()

    return player, enemies, boss_enemies, items


def main():  # Main loop function, plays on game start, used mainly for testing purposes
    setup_player()


# This conditional checks if the current script is the main program being executed
# rather than being imported from another script. "__name__" is a built-in variable
# in Python which is set to "__main__" when the script is executed directly.
if __name__ == "__main__":
    main()
